#load the libraries
library(Seurat)
library(ggplot2)
library(readr)
library(dplyr)
library(plotly)
library(patchwork)
library(fgsea)
library(msigdbr)
library(pheatmap)
library(ggridges)
library(clusterProfiler)
library(enrichplot)
library(tibble)

# Specify the file path
file_path <- "/home/zo24/SteeredResearchProject/groupproject/pipeline/4/re_analysis_counts_afterQC.csv"

# Read the reanalysis data after QC CSV file using read.csv
data <- read.csv(file_path, row.names = 1)  

# Convert the counts to a matrix
data_matrix <- as.matrix(data)

# Create the Seurat object from counts matrix
seurat_obj <- CreateSeuratObject(counts = data_matrix, project = "pipeline_analysis")

###pre-processing workfolw
#quality control and selecting cells for further analysis
#data normalisation
#identification of highly variable features )or feature selection)

###QC metrics (nFeature_RNA, nCount_RNA and percent.mt)
#low quality cells or empty droplets often have very few genes (low nFeature_RNA and nCount_RNA)
#cell doublets or multiplets have high nFeature_RNA and nCount_RNA
#dying/low-quality cells often have high mitochondrial genes percentage (percent.mt)

# Calculate and store the mitochondrial percentage in the metadata
seurat_obj <- PercentageFeatureSet(seurat_obj, pattern = "^MT", col.name = "percent.mt")

# violin plot to help choose the appropriate filtering parameters
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Create a scatter plot of nCount_RNA against percent.mt
FeatureScatter(object = seurat_obj, feature1 = "nCount_RNA", feature2 = "percent.mt")+
  theme(legend.position = "none")
# Create a scatter plot of nCount_RNA against nFeature_RNA
FeatureScatter(object = seurat_obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")+
  theme(legend.position = "none")

#filter the cells based on the parameters selected from the violin plot
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 2500 & nFeature_RNA < 10000 & nCount_RNA < 3e+06 & percent.mt < 15)

#violin plot after filtering to review the results
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Create a scatter plot of nCount_RNA against percent.mt AFTER FILTERING
FeatureScatter(object = seurat_obj, feature1 = "nCount_RNA", feature2 = "percent.mt")+
  theme(legend.position = "none")
# Create a scatter plot of nCount_RNA against nFeature_RNA AFTER FILTERING
FeatureScatter(object = seurat_obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")+
  theme(legend.position = "none")

# Normalize the data using log nomalisation
seurat_obj <- NormalizeData(seurat_obj,
                            normalization.method = "LogNormalize", scale.factor = 10000)

# identification of highly variable features
seurat_obj <- FindVariableFeatures(seurat_obj, 
                                   selection.method = "vst", nfeatures = 2000)

#variable feature plot to identift number of variable features
VariableFeaturePlot(seurat_obj)

# Perform scaling
seurat_obj <- ScaleData(seurat_obj)
all.genes <- rownames(seurat_obj)
seurat_obj <- ScaleData(seurat_obj, features = all.genes)


# Perform dimensionality reduction (PCA on the data)
seurat_obj <- RunPCA(seurat_obj)
seurat_obj <- RunPCA(seurat_obj, npcs = 50, features = VariableFeatures(object = seurat_obj), ndims.print = 1:5, nfeatures.print = 30)

#visualise PCA results
DimPlot(seurat_obj, reduction = "pca", dims = c(1,2))

#elbow plot
ElbowPlot(seurat_obj)
ElbowPlot(seurat_obj, ndims = 50, reduction = "pca")

# Cluster the cells
seurat_obj <- FindNeighbors(seurat_obj)
seurat_obj <- FindClusters(seurat_obj)
#seurat_obj <- FindClusters(seurat_obj, resolution = 0.3)
#seurat_obj <- FindClusters(seurat_obj, resolution = 0.5)

#run UMAP and t-SNE
seurat_obj <- RunUMAP(seurat_obj, dims = 1:20)
DimPlot(seurat_obj, reduction = "umap", label = TRUE, repel = TRUE)
seurat_obj <- RunTSNE(object = seurat_obj)
DimPlot(object = seurat_obj, reduction = "tsne")

# Visualize the clusters
DimPlot(seurat_obj)

#create new metadata category to identify cells as either Tumor or Metastases
seurat_obj$CellOrigin <- ifelse(grepl("Tumor", colnames(seurat_obj)), "Tumor", "Metastases")
table(seurat_obj$CellOrigin)

#visualise UMAP and t-SNE based on Cell Origin
DimPlot(seurat_obj, reduction = "umap", group.by = "CellOrigin", label = TRUE, repel = TRUE)
DimPlot(seurat_obj, reduction = "tsne", group.by = "CellOrigin")

#combine the generated visualisations to make them easier to compare
# t-SNE plots
tsne_clusters <- DimPlot(seurat_obj, reduction = "tsne", group.by = "seurat_clusters") + 
  ggtitle("t-SNE by Clusters")

tsne_cell_origin <- DimPlot(seurat_obj, reduction = "tsne", group.by = "CellOrigin") + 
  ggtitle("t-SNE by Cell Origin")

# Combine using patchwork
combined_tsne <- tsne_clusters + tsne_cell_origin
combined_tsne

# UMAP plots
umap_clusters <- DimPlot(seurat_obj, reduction = "umap", group.by = "seurat_clusters", label = TRUE, repel = TRUE) + 
  ggtitle("UMAP by Clusters")

umap_cell_origin <- DimPlot(seurat_obj, reduction = "umap", group.by = "CellOrigin", label = TRUE, repel = TRUE) + 
  ggtitle("UMAP by Cell Origin")

# Combine using patchwork
combined_umap <- umap_clusters + umap_cell_origin
combined_umap

#find top markers (most differentiall expressed genes)
markers <- FindAllMarkers(object = seurat_obj, only.pos = FALSE,  min.pct = 0.1, logfc.threshold = 0.25)


#visualise the differentially expressed genes in a volcano plot
volcano_plot <- ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val), color = p_val_adj < 0.05)) +
  geom_point(alpha = 0.4) +
  scale_color_manual(values = c("grey", "red")) +
  theme_minimal() +
  labs(title = "Volcano Plot", x = "Log2 Fold Change", y = "-Log10 P-value")
print(volcano_plot)

# Filter for the top upregulated and downregulated markers per cluster
top_markers_per_cluster <- markers %>%
  group_by(cluster) %>%
  top_n(n = 5, wt = avg_log2FC) %>%
  bind_rows(markers %>% 
              group_by(cluster) %>%
              top_n(n = 5, wt = -avg_log2FC))

# Get unique gene names from the top markers
top_genes <- unique(top_markers_per_cluster$gene)

# Extract the data for these genes
data_for_heatmap <- GetAssayData(seurat_obj, assay = "RNA", layer = "data")[top_genes, ]

#annotate the clusters to improve my visualisations
sample_metadata <- seurat_obj@meta.data
cluster_annotations <- sample_metadata[, "seurat_clusters", drop = FALSE]



ggplot(fgsea_results, aes(x = pathway, y = NES, color = padj < 0.05, size = -log10(padj))) +
  geom_point() +
  scale_color_manual(values = c("grey", "red")) +
  labs(x = "Pathway", y = "Normalized Enrichment Score (NES)", color = "Significant") +
  theme_minimal()

pheatmap(data_for_heatmap,
         color = colorRampPalette(c("navy", "white", "red"))(100),
         annotation_col = cluster_annotations,  # Add cluster annotations
         show_rownames = TRUE,                  # Show row names (gene names)
         show_colnames = FALSE,                 # Hide column names (cell types)
         fontsize_row = 10,                     # Adjust font size for row names if necessary
         fontsize_col = 10,                     # Adjust font size for column names if necessary
         border_color = NA) 

###set gene list to use for GSEA (using the Proliferation and EMT genes mentioned in the main paper)

#list of EMT genes
emt_genes <- c("KRT8", "ITGAV", "SERPINE1", "MET", "KRT18", "TGFBR1", "DSG2", "SPARC", "ITGB1", "ZEB1", "EMP3", "TNC", "EPCAM", "ST14", "KRT5", "ESRP1", "KRT14", "MMP2", "SNAI1", "COL1A1", "MUC1", "MYC", "CCN2", "FN1", "SOX9", "VIM", "KRT19")

#list of proliferation genes
proliferation_genes <- c("MKI67", "MCM3", "PCNA")

#combine the lists
combined_genes <- c(emt_genes, proliferation_genes)

# Using VlnPlot to visualize the distribution of expression levels across clusters
VlnPlot(seurat_obj, features = combined_genes[1:5], group.by = "seurat_clusters")

# Using DotPlot for a compact visualization
DotPlot(seurat_obj, features = combined_genes, group.by = "seurat_clusters") + RotatedAxis()

####Gene Set Enrichment Analysis

# Create a named list of gene sets
gene_sets <- list(
  EMT = as.character(emt_genes),
  Proliferation = as.character(proliferation_genes)
)

# Sort the markers dataframe by the ranking metric column and create a named vector
ranked_gene_list <- markers_sorted$rank_metric
names(ranked_gene_list) <- markers_sorted$gene

# Sorting the ranked_gene_list after assigning names
ranked_gene_list <- sort(ranked_gene_list, decreasing = TRUE)


# Handling duplicates while maintaining names
if(any(duplicated(names(ranked_gene_list)))) {
  temp <- tapply(ranked_gene_list, names(ranked_gene_list), mean)
  ranked_gene_list <- sort(temp, decreasing = TRUE)
  names(ranked_gene_list) <- names(temp)  # Ensure names are carried over from temp
}

# Verify common genes are correctly identified
common_genes <- intersect(names(ranked_gene_list), unlist(gene_sets))
if (length(common_genes) < length(names(ranked_gene_list))) {
  ranked_gene_list <- ranked_gene_list[names(ranked_gene_list) %in% common_genes]
  gene_sets <- lapply(gene_sets, function(x) x[x %in% common_genes])
}
print(head(names(ranked_gene_list)))

# Correctly ensuring it's a numeric vector with names
ranked_gene_list <- as.numeric(ranked_gene_list)  # Ensures it's numeric
names(ranked_gene_list) <- names(ranked_gene_list)  # Re-assign names if lost

print(class(ranked_gene_list))
print(is.numeric(ranked_gene_list))
print(head(ranked_gene_list))
print(head(names(ranked_gene_list)))
print(head(gene_sets$EMT))
print(names(gene_sets))

gsea_results <- GSEA(ranked_gene_list,
                     TERM2GENE = gene_sets,
                     pAdjustMethod = "BH",
                     minGSSize = 2,
                     maxGSSize = 500,
                     verbose = TRUE)


# Check the results
if (length(gsea_results) == 0) {
  print("No significant pathways found.")
} else {
  print("GSEA ran successfully, check results for significance.")
  print(as.data.frame(gsea_results))  # Using as.data.frame for a better format
}

# Create a binary matrix for gene membership in gene sets
membership_matrix <- sapply(geneSets, function(gs) as.integer(names(geneList) %in% gs))

# Then convert to a data frame for pheatmap
membership_df <- as.data.frame(membership_matrix)
rownames(membership_df) <- names(geneList)

# Extract the gene list and their ranks from the S4 object
geneList <- gsea_results@geneList

# Extract the gene sets from the S4 object
geneSets <- gsea_results@geneSets

# Create a matrix to store the ranks for heatmap plotting
# Initialize the matrix with NA values
heatmap_matrix <- matrix(NA, nrow = length(geneList), ncol = length(geneSets), 
                         dimnames = list(names(geneList), names(geneSets)))

# Fill the matrix with ranks
for (i in seq_along(geneSets)) {
  genes_in_set <- geneSets[[i]]
  heatmap_matrix[genes_in_set, i] <- geneList[genes_in_set]
}

# Replace NA with 0 or any other value to represent absent genes
heatmap_matrix[is.na(heatmap_matrix)] <- 0


# Plotting the heatmap
pheatmap(heatmap_matrix, color = colorRampPalette(c("navy", "white", "firebrick3"))(100), 
         clustering_distance_rows = 'correlation', clustering_distance_cols = 'correlation')



# Enrichment plot for the first significant gene set
gseaplot(gsea_results, geneSetID = which.min(gsea_results$adjPVal), title = names(gene_sets)[which.min(gsea_results$adjPVal)])

# Ridge plot for all significant gene sets
ridgeplot(gsea_results)

# Dot plot for visualization of multiple gene sets
dotplot(gsea_results)

# Enrichment map
emapplot(gsea_results)

###making interactive plots for the website

# Interactive violin plot after filtering
p_violin_after <- ggplotly(
  VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
)
p_violin_after

# Interactive scatter plot of nCount_RNA against percent.mt
p_scatter1 <- plotly::ggplotly(
  ggplot(seurat_obj@meta.data, aes(x = nCount_RNA, y = percent.mt)) +
    geom_point() +
    theme_minimal()
)

# Interactive scatter plot of nCount_RNA against nFeature_RNA
p_scatter2 <- plotly::ggplotly(
  ggplot(seurat_obj@meta.data, aes(x = nCount_RNA, y = nFeature_RNA)) +
    geom_point() +
    theme_minimal()
)

# Display interactive plots
p_scatter1
p_scatter2

# Create t-SNE plots for clusters and cell origin
tsne_clusters <- DimPlot(seurat_obj, reduction = "tsne", group.by = "seurat_clusters") + 
  ggtitle("t-SNE by Clusters") +
  theme(legend.position = "none")  # Remove the default legend

tsne_cell_origin <- DimPlot(seurat_obj, reduction = "tsne", group.by = "CellOrigin") + 
  ggtitle("t-SNE by Cell Origin") +
  theme(legend.position = "none")  # Remove the default legend

# Convert to interactive plotly objects
tsne_clusters_interactive <- ggplotly(tsne_clusters, tooltip = "text")
tsne_cell_origin_interactive <- ggplotly(tsne_cell_origin, tooltip = "text")

# Combine using subplot
combined_tsne_interactive <- subplot(tsne_clusters_interactive, tsne_cell_origin_interactive, 
                                     nrows = 1, shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE)

# Adjust layout to include legends and title
combined_tsne_interactive <- combined_tsne_interactive %>% 
  layout(title = "t-SNE by Clusters vs. Cell Origin",
         showlegend = TRUE,
         legend = list(x = 1.02, y = 0.5, orientation = "v"),
         annotations = list(
           list(x = 0.25, y = 1.07, text = "Clusters", showarrow = F, xref = 'paper', yref = 'paper'),
           list(x = 0.75, y = 1.07, text = "Cell Origin", showarrow = F, xref = 'paper', yref = 'paper')
         ))

# Print the interactive plot
combined_tsne_interactive

# Create UMAP plots for clusters and cell origin
umap_clusters <- DimPlot(seurat_obj, reduction = "umap", group.by = "seurat_clusters", label = TRUE, repel = TRUE) + 
  ggtitle("UMAP by Clusters") +
  theme(legend.position = "none")  # Remove the default legend

umap_cell_origin <- DimPlot(seurat_obj, reduction = "umap", group.by = "CellOrigin", label = TRUE, repel = TRUE) + 
  ggtitle("UMAP by Cell Origin") +
  theme(legend.position = "none")  # Remove the default legend

# Convert to interactive plotly objects
umap_clusters_interactive <- ggplotly(umap_clusters, tooltip = "text")
umap_cell_origin_interactive <- ggplotly(umap_cell_origin, tooltip = "text")

# Combine using subplot
combined_umap_interactive <- subplot(umap_clusters_interactive, umap_cell_origin_interactive, 
                                     nrows = 1, shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE)

# Adjust layout to include legends and title
combined_umap_interactive <- combined_umap_interactive %>% 
  layout(title = "UMAP by Clusters vs. Cell Origin",
         showlegend = TRUE,
         legend = list(x = 1.02, y = 0.5, orientation = "v"),
         annotations = list(
           list(x = 0.25, y = 1.07, text = "Clusters", showarrow = F, xref = 'paper', yref = 'paper'),
           list(x = 0.75, y = 1.07, text = "Cell Origin", showarrow = F, xref = 'paper', yref = 'paper')
         ))

# Print the interactive plot
combined_umap_interactive

# Ensure the markers dataframe includes negative log10 of p-value for plotting
markers$neg_log10_p_val <- -log10(markers$p_val)

# Generate the volcano plot using ggplot2
volcano_plot <- ggplot(markers, aes(x = avg_log2FC, y = neg_log10_p_val, color = p_val_adj < 0.05)) +
  geom_point(alpha = 0.4) +
  scale_color_manual(values = c("grey", "red")) +
  theme_minimal() +
  labs(title = "Volcano Plot", x = "Log2 Fold Change", y = "-Log10 P-value")

# Check the plot
print(volcano_plot)
#convert to interactive
p_volcano_interactive <- ggplotly(volcano_plot)
# Display the interactive plot
p_volcano_interactive

# Convert DotPlot to interactive
p_dot <- DotPlot(seurat_obj, features = updated_genes, group.by = "seurat_clusters") + RotatedAxis()
p_dot_interactive <- ggplotly(p_dot)
p_dot_interactive

